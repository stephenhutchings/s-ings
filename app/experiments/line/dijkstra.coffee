'use strict'

###*****************************************************************************
# Created 2008-08-19.
#
# Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
#
# Copyright (C) 2008
#   Wyatt Baldwin <self@wyattbaldwin.com>
#   All rights reserved
#
# Licensed under the MIT license.
#
#   http://www.opensource.org/licenses/mit-license.php
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#***************************************************************************
###

dijkstra =
  single_source_shortest_paths: (graph, s, d) ->
    # Predecessor map for each node that has been encountered.
    # node ID => predecessor node ID
    predecessors = {}
    # Costs of shortest paths from s to all nodes encountered.
    # node ID => cost
    costs = {}
    costs[s] = 0
    # Costs of shortest paths from s to all nodes encountered; differs from
    # `costs` in that it provides easy access to the node that currently has
    # the known shortest path from s.
    # XXX: Do we actually need both `costs` and `open`?
    open = dijkstra.PriorityQueue.make()
    open.push s, 0
    closest = undefined
    u = undefined
    v = undefined
    cost_of_s_to_u = undefined
    adjacent_nodes = undefined
    cost_of_e = undefined
    cost_of_s_to_u_plus_cost_of_e = undefined
    cost_of_s_to_v = undefined
    first_visit = undefined
    while !open.empty()
      # In the nodes remaining in graph that have a known cost from s,
      # find the node, u, that currently has the shortest path from s.
      closest = open.pop()
      u = closest.value
      cost_of_s_to_u = closest.cost
      # Get nodes adjacent to u...
      adjacent_nodes = graph[u] or {}
      # ...and explore the edges that connect u to those nodes, updating
      # the cost of the shortest paths to any or all of those nodes as
      # necessary. v is the node across the current edge from u.
      for v of adjacent_nodes
        `v = v`
        if adjacent_nodes.hasOwnProperty(v)
          # Get the cost of the edge running from u to v.
          cost_of_e = adjacent_nodes[v]
          # Cost of s to u plus the cost of u to v across e--this is *a*
          # cost from s to v that may or may not be less than the current
          # known cost to v.
          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e
          # If we haven't visited v yet OR if the current known cost from s to
          # v is greater than the new cost we just found (cost of s to u plus
          # cost of u to v across e), update v's cost in the cost list and
          # update v's predecessor in the predecessor list (it's now u).
          cost_of_s_to_v = costs[v]
          first_visit = typeof costs[v] == 'undefined'
          if first_visit or cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e
            costs[v] = cost_of_s_to_u_plus_cost_of_e
            open.push v, cost_of_s_to_u_plus_cost_of_e
            predecessors[v] = u
    if typeof d != 'undefined' and typeof costs[d] == 'undefined'
      msg = [
        'Could not find a path from '
        s
        ' to '
        d
        '.'
      ].join('')
      throw new Error(msg)
    predecessors
  extract_shortest_path_from_predecessor_list: (predecessors, d) ->
    nodes = []
    u = d
    predecessor = undefined
    while u
      nodes.push u
      predecessor = predecessors[u]
      u = predecessors[u]
    nodes.reverse()
    nodes
  find_path: (graph, s, d) ->
    predecessors = dijkstra.single_source_shortest_paths(graph, s, d)
    dijkstra.extract_shortest_path_from_predecessor_list predecessors, d
  PriorityQueue:
    make: (opts) ->
      T = dijkstra.PriorityQueue
      t = {}
      key = undefined
      opts = opts or {}
      for key of T
        `key = key`
        if T.hasOwnProperty(key)
          t[key] = T[key]
      t.queue = []
      t.sorter = opts.sorter or T.default_sorter
      t
    default_sorter: (a, b) ->
      a.cost - (b.cost)
    push: (value, cost) ->
      item =
        value: value
        cost: cost
      @queue.push item
      @queue.sort @sorter
      return
    pop: ->
      @queue.shift()
    empty: ->
      @queue.length == 0
# node.js module exports
if typeof module != 'undefined'
  module.exports = dijkstra

# ---
# generated by js2coffee 2.2.0
